<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Big Text Display</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: #f5f5f5;
        }
        
        .controls {
            padding: 15px;
            background: white;
            border-bottom: 2px solid #ddd;
        }
        
        .control-group {
            margin-bottom: 12px;
        }
        
        label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 4px;
            color: #333;
        }
        
        input[type="text"], textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 16px;
        }
        
        textarea {
            min-height: 60px;
            resize: vertical;
        }
        
        .color-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .color-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .color-control label {
            margin: 0;
            flex: 1;
        }
        
        input[type="color"] {
            width: 50px;
            height: 35px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
        }
        
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            vertical-align: middle;
        }
        
        label:has(input[type="checkbox"]) {
            display: flex;
            align-items: center;
            margin-bottom: 0;
        }
        
        .mode-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }
        
        button {
            padding: 12px;
            border: 2px solid #007AFF;
            border-radius: 8px;
            background: white;
            color: #007AFF;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        button:active {
            transform: scale(0.95);
        }
        
        button.active {
            background: #007AFF;
            color: white;
        }
        
        .scaling-btn {
            /* Use same styles as other buttons */
        }
        
        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        input[type="range"] {
            flex: 1;
        }
        
        .speed-value {
            min-width: 45px;
            text-align: right;
            font-size: 12px;
            font-weight: 600;
            color: #666;
        }
        
        .display-area {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            text-align: center;
            padding: 20px;
            word-wrap: break-word;
            overflow: hidden;
        }
        
        .display-area.active {
            display: flex;
        }
        
        .display-text {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            line-height: 1.2;
            white-space: nowrap;
        }
        
        .scrolling-container {
            width: 100%;
            overflow: hidden;
            white-space: nowrap;
        }
        
        .scrolling-text {
            display: inline-block;
            padding-left: 100%;
            animation: scroll linear infinite;
        }
        
        @keyframes scroll {
            0% {
                transform: translateX(0);
            }
            100% {
                transform: translateX(-100%);
            }
        }
        
        .close-btn {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            border: none;
            font-size: 24px;
            z-index: 1000;
            display: none;
        }
        
        .display-area.active + .close-btn {
            display: block;
        }
        
        .nav-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: 2px solid white;
            font-size: 24px;
        }
        
        .toggle-controls {
            margin-top: 10px;
        }
        
        .toggle-controls button {
            width: 100%;
        }
    </style>
</head>
<body>
    <div class="controls" id="controls">
        <div class="control-group">
            <label for="messageInput">Message</label>
            <textarea id="messageInput" placeholder="Enter your message here...">OMELET</textarea>
        </div>
        
        <div class="control-group">
            <label>Display Mode</label>
            <div class="mode-buttons">
                <button id="staticBtn" class="mode-btn">Static</button>
                <button id="scrollBtn" class="mode-btn">Scroll</button>
                <button id="slideshowBtn" class="mode-btn">Slideshow</button>
            </div>
        </div>
        
        <div class="control-group">
            <label>Colors</label>
            <div class="color-controls">
                <div class="color-control">
                    <label for="textColor">Text</label>
                    <input type="color" id="textColor" value="#ffffff">
                </div>
                <div class="color-control">
                    <label for="bgColor">Background</label>
                    <input type="color" id="bgColor" value="#000000">
                </div>
            </div>
        </div>
        
        <div class="control-group" id="speedControl">
            <label for="speedSlider">Speed</label>
            <div class="speed-control">
                <input type="range" id="speedSlider" min="1" max="10" value="5">
                <span class="speed-value" id="speedValue">5</span>
            </div>
        </div>
        
        <div class="control-group">
            <label for="fontSizeSlider">Font Size</label>
            <div class="speed-control">
                <input type="range" id="fontSizeSlider" min="1" max="200" value="100">
                <span class="speed-value" id="fontSizeValue">100</span>
            </div>
        </div>
        
        <div class="control-group" id="scalingModeControl" style="display: none;">
            <label>Scaling Mode (Slideshow)</label>
            <div class="mode-buttons">
                <button id="fitBtn" class="scaling-btn active">Fit</button>
                <button id="fillBtn" class="scaling-btn">Fill</button>
                <button id="balancedBtn" class="scaling-btn">Avg</button>
            </div>
        </div>
        
        <div class="control-group">
            <label>
                <input type="checkbox" id="debugLogging" checked>
                <span style="font-weight: 600; margin-left: 5px;">Show Console Output</span>
            </label>
        </div>
        
        <div class="toggle-controls">
            <button id="showBtn" class="active">Show Display</button>
        </div>
    </div>
    
    <div class="display-area" id="displayArea">
        <div class="display-text" id="displayText"></div>
    </div>
    
    <button class="close-btn" id="closeBtn">Ã—</button>
    
    <div id="measurementDiv" style="position: fixed; visibility: hidden; white-space: nowrap;"></div>

    <script>
        const messageInput = document.getElementById('messageInput');
        const displayArea = document.getElementById('displayArea');
        const displayText = document.getElementById('displayText');
        const staticBtn = document.getElementById('staticBtn');
        const scrollBtn = document.getElementById('scrollBtn');
        const slideshowBtn = document.getElementById('slideshowBtn');
        const textColorInput = document.getElementById('textColor');
        const bgColorInput = document.getElementById('bgColor');
        const speedSlider = document.getElementById('speedSlider');
        const speedValue = document.getElementById('speedValue');
        const showBtn = document.getElementById('showBtn');
        const closeBtn = document.getElementById('closeBtn');
        const controls = document.getElementById('controls');
        const speedControl = document.getElementById('speedControl');
        const fontSizeSlider = document.getElementById('fontSizeSlider');
        const fontSizeValue = document.getElementById('fontSizeValue');
        const measurementDiv = document.getElementById('measurementDiv');
        const scalingModeControl = document.getElementById('scalingModeControl');
        const fitBtn = document.getElementById('fitBtn');
        const fillBtn = document.getElementById('fillBtn');
        const balancedBtn = document.getElementById('balancedBtn');
        const debugLogging = document.getElementById('debugLogging');
        
        let currentMode = 'static';
        let currentLetterIndex = 0;
        let slideshowInterval = null;
        let optimalFontSize = 100; // vmin value where largest char fits perfectly
        let optimalFontUnit = 'vmin'; // unit to use for optimal font size
        let scalingMode = 'fit'; // 'fit', 'fill', or 'balanced'
        
        // Helper function for conditional logging
        function log(...args) {
            if (debugLogging.checked) {
                console.log(...args);
            }
        }
        
        // Calculate optimal font size for a message (where largest char fits screen)
        function calculateOptimalFontSize(message) {
            if (!message) return 100;
            
            const characters = Array.from(message);
            const uniqueChars = [...new Set(characters)];
            
            log('=== CALCULATING OPTIMAL FONT SIZE ===');
            log('Message:', message);
            log('Unique characters:', uniqueChars);
            log('Scaling mode:', scalingMode);
            
            // Test size - always use vmin for measurement
            const testSize = 100;
            measurementDiv.style.fontSize = `${testSize}vmin`;
            
            // Get viewport dimensions
            const vw = window.innerWidth;
            const vh = window.innerHeight;
            const isPortrait = vh > vw;
            
            log('Viewport:', vw, 'x', vh, isPortrait ? '(portrait)' : '(landscape)');
            
            // Track the maximum width and maximum height across all characters
            let maxWidth = 0;
            let maxHeight = 0;
            let widestChar = '';
            let tallestChar = '';
            
            uniqueChars.forEach(char => {
                measurementDiv.textContent = char;
                const rect = measurementDiv.getBoundingClientRect();
                
                log(`  "${char}": ${rect.width.toFixed(2)}px wide, ${rect.height.toFixed(2)}px tall`);
                
                if (rect.width > maxWidth) {
                    maxWidth = rect.width;
                    widestChar = char;
                }
                if (rect.height > maxHeight) {
                    maxHeight = rect.height;
                    tallestChar = char;
                }
            });
            
            log(`Widest char: "${widestChar}" at ${maxWidth.toFixed(2)}px`);
            log(`Tallest char: "${tallestChar}" at ${maxHeight.toFixed(2)}px`);
            
            // Calculate ratios: what percentage of viewport does the max bounding box take?
            const widthRatio = maxWidth / vw;
            const heightRatio = maxHeight / vh;
            
            log(`Width ratio: ${widthRatio.toFixed(4)} (${(widthRatio * 100).toFixed(2)}% of viewport width)`);
            log(`Height ratio: ${heightRatio.toFixed(4)} (${(heightRatio * 100).toFixed(2)}% of viewport height)`);
            
            let constraintRatio;
            let unit;
            
            if (scalingMode === 'fit') {
                // Fit: constrained by whichever dimension hits the edge first (the larger ratio)
                constraintRatio = Math.max(widthRatio, heightRatio);
                unit = 'vmin';
                log(`FIT mode: constrained by ${widthRatio > heightRatio ? 'WIDTH' : 'HEIGHT'}`);
            } else if (scalingMode === 'fill') {
                // Fill: constrained by whichever dimension hits the edge last (the smaller ratio)
                constraintRatio = Math.min(widthRatio, heightRatio);
                unit = 'vmax';
                log(`FILL mode: constrained by ${widthRatio < heightRatio ? 'WIDTH' : 'HEIGHT'}`);
            } else { // 'balanced'
                // Average of both dimensions
                constraintRatio = (widthRatio + heightRatio) / 2;
                unit = 'vmin';
                log('BALANCED mode: using average of both dimensions');
            }
            
            log(`Constraint ratio: ${constraintRatio.toFixed(4)}`);
            
            // Store the unit for later use
            optimalFontUnit = unit;
            
            // Calculate what font size would make the largest char fit edge-to-edge
            if (constraintRatio > 0) {
                const targetRatio = 1.0; // 100% of viewport (edge-to-edge)
                const optimalSize = (testSize * targetRatio) / constraintRatio;
                log(`Optimal font size: ${optimalSize.toFixed(2)}${unit} (at 100%)`);
                log('===================================\n');
                return optimalSize;
            }
            
            log('ERROR: constraint ratio was 0');
            log('===================================\n');
            return 100;
        }
        
        // Update speed display
        speedSlider.addEventListener('input', () => {
            speedValue.textContent = speedSlider.value;
            if (currentMode === 'scroll') {
                updateScrollSpeed();
            } else if (currentMode === 'slideshow' && displayArea.classList.contains('active')) {
                startSlideshow(); // Restart with new speed
            }
        });
        
        // Update font size display
        fontSizeSlider.addEventListener('input', () => {
            fontSizeValue.textContent = fontSizeSlider.value;
            if (displayArea.classList.contains('active')) {
                updateDisplay();
            }
        });
        
        // Mode buttons
        function setMode(mode) {
            currentMode = mode;
            [staticBtn, scrollBtn, slideshowBtn].forEach(btn => btn.classList.remove('active'));
            
            if (mode === 'static') {
                staticBtn.classList.add('active');
                speedControl.style.display = 'none';
                scalingModeControl.style.display = 'none';
                displayArea.classList.remove('slideshow');
            } else if (mode === 'scroll') {
                scrollBtn.classList.add('active');
                speedControl.style.display = 'block';
                scalingModeControl.style.display = 'none';
                displayArea.classList.remove('slideshow');
            } else if (mode === 'slideshow') {
                slideshowBtn.classList.add('active');
                speedControl.style.display = 'block';
                scalingModeControl.style.display = 'block';
                displayArea.classList.add('slideshow');
            }
            
            if (displayArea.classList.contains('active')) {
                updateDisplay();
            }
        }
        
        staticBtn.addEventListener('click', () => setMode('static'));
        scrollBtn.addEventListener('click', () => setMode('scroll'));
        slideshowBtn.addEventListener('click', () => setMode('slideshow'));
        
        // Scaling mode buttons
        function setScalingMode(mode) {
            scalingMode = mode;
            [fitBtn, fillBtn, balancedBtn].forEach(btn => btn.classList.remove('active'));
            
            if (mode === 'fit') {
                fitBtn.classList.add('active');
            } else if (mode === 'fill') {
                fillBtn.classList.add('active');
            } else if (mode === 'balanced') {
                balancedBtn.classList.add('active');
            }
            
            // Recalculate if in slideshow mode and display is active
            if (currentMode === 'slideshow' && displayArea.classList.contains('active')) {
                const message = messageInput.value || 'OMELET';
                optimalFontSize = calculateOptimalFontSize(message);
                updateSlideshowLetter(message);
            }
        }
        
        fitBtn.addEventListener('click', () => setScalingMode('fit'));
        fillBtn.addEventListener('click', () => setScalingMode('fill'));
        balancedBtn.addEventListener('click', () => setScalingMode('balanced'));
        
        // Color controls
        textColorInput.addEventListener('input', updateColors);
        bgColorInput.addEventListener('input', updateColors);
        
        function updateColors() {
            displayArea.style.color = textColorInput.value;
            displayArea.style.background = bgColorInput.value;
        }
        
        // Show/hide display
        showBtn.addEventListener('click', () => {
            if (displayArea.classList.contains('active')) {
                hideDisplay();
            } else {
                showDisplay();
            }
        });
        
        closeBtn.addEventListener('click', hideDisplay);
        
        function showDisplay() {
            displayArea.classList.add('active');
            controls.style.display = 'none';
            showBtn.textContent = 'Hide Display';
            updateDisplay();
            updateColors();
        }
        
        function hideDisplay() {
            displayArea.classList.remove('active');
            controls.style.display = 'block';
            showBtn.textContent = 'Show Display';
            if (slideshowInterval) {
                clearInterval(slideshowInterval);
                slideshowInterval = null;
            }
        }
        
        function updateDisplay() {
            const message = messageInput.value || 'OMELET';
            const fontSizeMultiplier = fontSizeSlider.value / 100; // 0.01 to 2.0
            
            if (currentMode === 'static') {
                displayText.innerHTML = message;
                const baseFontSize = calculateBaseFontSize(message);
                displayText.style.fontSize = `calc(${baseFontSize} * ${fontSizeMultiplier * 2.5})`;
                displayText.className = 'display-text';
            } else if (currentMode === 'scroll') {
                displayText.innerHTML = `<div class="scrolling-container"><div class="scrolling-text">${message}</div></div>`;
                displayText.style.fontSize = `calc(15vmin * ${fontSizeMultiplier * 2.5})`;
                displayText.className = 'display-text';
                updateScrollSpeed();
            } else if (currentMode === 'slideshow') {
                // Calculate optimal size for this message
                optimalFontSize = calculateOptimalFontSize(message);
                currentLetterIndex = 0;
                updateSlideshowLetter(message);
                startSlideshow(); // Auto-start slideshow
            }
        }
        
        function calculateBaseFontSize(text) {
            const length = text.length;
            if (length <= 3) return '35vmin';
            if (length <= 6) return '25vmin';
            if (length <= 10) return '18vmin';
            if (length <= 15) return '12vmin';
            if (length <= 25) return '10vmin';
            if (length <= 40) return '7vmin';
            return '5vmin';
        }
        
        function updateScrollSpeed() {
            const speed = speedSlider.value;
            const duration = 20 - (speed * 1.5); // 5s to 20s
            const scrollingText = document.querySelector('.scrolling-text');
            if (scrollingText) {
                scrollingText.style.animationDuration = `${duration}s`;
            }
        }
        
        function updateSlideshowLetter(message) {
            if (message.length === 0) return;
            
            const characters = Array.from(message); // Properly handle emojis and multi-byte chars
            const letter = characters[currentLetterIndex];
            const fontSizeMultiplier = fontSizeSlider.value / 100; // Slider value 100 = perfect fit, 200 = 2x
            
            const finalSize = optimalFontSize * fontSizeMultiplier;
            
            log(`Displaying "${letter}": ${finalSize.toFixed(2)}${optimalFontUnit} (optimal: ${optimalFontSize.toFixed(2)}, multiplier: ${fontSizeMultiplier})`);
            
            displayText.innerHTML = letter;
            displayText.style.fontSize = `${finalSize}${optimalFontUnit}`;
            displayText.className = 'display-text';
        }
        
        function startSlideshow() {
            if (slideshowInterval) {
                clearInterval(slideshowInterval);
            }
            
            const speed = speedSlider.value;
            const interval = 2000 - (speed * 150); // 500ms to 1850ms
            
            slideshowInterval = setInterval(() => {
                const message = messageInput.value || 'OMELET';
                const characters = Array.from(message);
                currentLetterIndex = (currentLetterIndex + 1) % characters.length;
                updateSlideshowLetter(message);
            }, interval);
        }
        
        // Update display when message changes
        messageInput.addEventListener('input', () => {
            if (displayArea.classList.contains('active')) {
                if (currentMode === 'slideshow') {
                    const message = messageInput.value || 'OMELET';
                    const characters = Array.from(message);
                    if (currentLetterIndex >= characters.length) {
                        currentLetterIndex = 0;
                    }
                    // Recalculate optimal size for new message
                    optimalFontSize = calculateOptimalFontSize(message);
                }
                updateDisplay();
            }
        });
        
        // Initialize with static mode
        setMode('static');
    </script>
</body>
</html>